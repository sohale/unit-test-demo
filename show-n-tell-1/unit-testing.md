
# Unit Testing: How & Why

## Why (motivation)
<!-- Managing complexity and difficulty.-->
Human nature: Errors are normal
<!-- give Disciplines to  -->
<!-- a bit of push? -->

Human nature: Errors are normal
Humans under stress
Lump of complexity
Large projects growth:
* scaling up the growth
* Sustainable growth

Verification: Other types versus Unit Tests
Quality? Non-primacy of Quality: Quality is not Primary

## How (with live coding) (technical): part 1
Case 1: Algorithm: Prime numbers


Writing code for an algorithm (Prime numbers)
* Iterative
* Continuous (CI: small modificaitons)
<!-- * CI: communication: merge contiually -->

TDD
* Green-red: refactoring
* Interface first
* Separating interface from implementation details
* decomposing


## History & Context

QA (Quality, QA teams, pre-2000)

* Kent Beck (and consequences)
   * SUnit
   * XP
   * Agile (later)
* Refactoring
   * Start imperfect
   * Pragmatism
* TDD
* Some milestones: 2000,2005,2012
* DORA study

More objective assessment: DORA

Where to look:
* The XP book
* The Tidy First
* (The DORA report)
* The book "Accelerate"

## Best practices (how)
* The person who wrote the code should write it
* As early as possible
* Even before the code (TDD: Shift-left)
* Unseparable part of writing the code
* Refactoring
* Shapes the code
* Readability (communication)
* Sepearation of modules, parts, etc
   * Interface
* (Team dynamics) Pyramid
### Why?
Why it works? / why this way? Seems magical.
* Curse of dimensionality

* Almost magic: Less cost, faster, ...
* IKEA example: Know earlier
* Detachable parts
* Offloading from QA

## Personal observations (in my career)
### Observations in past companies
* Helping avoid crashing
* Helping in costs
* Scaling up better practices in software, team work
### Discussions
* Spoken to people I know. Checked with people.
* Videos by
   * Dave Farley (videos and book)
   * Kent Beck
   * Lots of good videos about Unit Tests
   and bad ones
* Assessment

* "Scientific", "Causality"

## How (with live coding) (technical): part 2
ROS2 components
useful patterns
CMake structure (2 types)

### Suggestions:
* Separate QA for "software"
* Technical debt
* Coverage report
* Transition phase
* Affects planning
