
# Unit Testing: How & Why

## Why (motivation)
<!-- Managing complexity and difficulty.-->
Human nature: Errors are normal
<!-- give Disciplines to  -->
<!-- a bit of push? -->

Verification versus Unit Tests

## How (with live coding) (technical): part 1
Case 1: Algorithm: Prime numbers

TDD

## History & Context

QA (Quality, QA teams, pre-2000)

* Kent Beck (and consequences)
* Refactoring
* TDD
* DORA study

More objective assessment: DORA

Where to look:
* The XP book
* The Tidy First
* (The DORA report)
* The book "Accelerate"

## Best practices (how)
* The person who wrote the code should write it
* As early as possible
* Even before the code (TDD: Shift-left)
* Unseparable part of writing the code
* Refactoring
* Shapes the code
* Readability (communication)
* Sepearation of modules, parts, etc
* (Team dynamics) Pyramid
### Why?
Why it works? / why this way? Seems magical.
* Curse of dimensionality

* Almost magic: Less cost, faster, ...
* IKEA example: Know earlier
* Detachable parts
* Offloading from QA

## Personal observations (in my career)
### Observations in past companies
* Helping avoid crashing
* Helping in costs
* Scaling up better practices in software, team work
### Discussions
* Spoken to people I know. Checked with people.
* Videos by
   * Dave Farley (videos and book)
   * Kent Beck
   * Lots of good videos about Unit Tests
   and bad ones
* Assessment

* "Scientific", "Causality"

## How (with live coding) (technical): part 2
ROS2 components
useful patterns
CMake structure (2 types)

### Suggestions:
* Separate QA for "software"
* Technical debt
* Coverage report
* Transition phase
* Affects planning
